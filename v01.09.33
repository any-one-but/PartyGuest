// ==UserScript==
// @name         _PartyGuest
// @version      01.09.33
// @description  A tool for downloading images and videos from Coomer/Kemono
// @author       normal person
// @match        *://coomer.st/*
// @match        *://kemono.cr/*
// @grant        GM_download
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @connect      *
// ==/UserScript==



GM_addStyle(`
:root{--beige:#E3DCCB;--black:#1A1A1A;--desk:#7D7D7D;--light:#D8D8D8;--rain-red:#FF3B30;--rain-orange:#FF9500;--rain-yellow:#FFCC00;--rain-green:#34C759;--rain-blue:#007AFF;--rain-yellow:#FFCC00;--rain-indigo:#5856D6}
button{transition:transform .15s cubic-bezier(.2,.8,.4,1),filter .15s}
button:hover{transform:translateY(-2px);filter:brightness(1.1)}
button:active{transform:translateY(0)}
.full{width:100%}
.post__files{display:grid;grid-template-columns:repeat(8,minmax(0,1fr));gap:6px;justify-items:left;}
.post__thumbnail img{width:100%;height:auto;border-radius:8px;border:2px solid var(--rain-orange);box-shadow:0 2px 6px rgba(0,0,0,.25);transition:transform .2s,box-shadow .2s;cursor:pointer;}
.post__thumbnail img:hover{transform:scale(1.08);box-shadow:0 4px 15px rgba(0,0,0,.35);}
.post__nav-links{position:sticky;top:5px;z-index:100;background:var(--beige);padding:4px 8px;border-radius:8px;border:2px solid #7D7D7D;margin:5px auto;width:98%;}
.post__body>.ad-container,[class*="bottomRight--"],[class*="slideAnimation--"]{display:none!important;}
.ad-container-slider{background:transparent!important}
#partyHUD{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:10px;
  z-index:9999;
  background:var(--beige);
  color:var(--black);
  padding:8px 12px;
  border-radius:10px;
  border:2px solid #7D7D7D;
  font:16px/1.35 "Inter",sans-serif;
  display:flex;
  flex-direction:column;
  gap:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.25);
  width:max-content;
  max-width:98vw;
}
#partyHUD .full{width:auto}
#hudRow{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:8px;
  width:auto;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
}
#hudRow > button{flex:0 0 auto}
#partyHUD input[type="text"],#partyHUD input[type="number"]{background:#F5F1E8;color:var(--black);border:1px solid #A8A8A8;border-radius:6px;padding:7px 8px}
#hudRow input[type="text"],#hudRow input[type="number"]{width:120px;flex:0 0 auto}
#partyHUD button{font-size:16px;text-shadow:0 3px 0 rgba(0,0,0,.15);padding:10px 12px;font-weight:700;color:#fff;border:none;border-radius:8px;cursor:pointer;box-shadow:inset 0 -2px 0 rgba(0,0,0,.2)}
#dlBtn{background:var(--rain-blue)}
#dlBtn.stop{background:var(--rain-red)}
#queueBtn{background:var(--rain-blue)!important}
#filterBtn{background:var(--rain-green)}
#btnMedia{background:var(--rain-orange)!important;min-width:90px}
#scrapeBtn{background:var(--rain-indigo)}
#clearBtn{background:var(--rain-red)}
#filterBox{background:#fff;border:2px solid #7D7D7D;border-radius:8px;padding:8px 10px;min-height:30px;display:inline-flex;align-items:center;color:#000;align-self:stretch;width:100%;gap:10px}
#filterStatus{flex:1 1 auto;min-width:0}
#pgRight{margin-left:auto;display:flex;align-items:center;gap:10px;white-space:nowrap}
#pgMini{display:flex;align-items:center;gap:10px;white-space:nowrap}
#pgDrop{display:flex;align-items:center;gap:10px;white-space:nowrap}
#pgWrap{width:calc(100% - 24px);display:flex;align-items:center;gap:8px}
#pgTrack{position:relative;flex:1 1 auto;height:8px;background:#eee;border:1px solid #C8C8C8;border-radius:6px;overflow:hidden}
#pgFill{position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,var(--rain-blue),#5AA9FF);transition:width .25s ease}
#pgBarLabel{font-weight:700;font-size:12px;color:var(--black);min-width:34px;text-align:right}
.pgDot{opacity:.6}
.post__thumbnail{position:relative}
.pg-post-select-wrap{position:absolute;bottom:4px;right:4px;display:flex;align-items:center;gap:4px;z-index:9999;min-width:28px;min-height:28px;justify-content:flex-end;cursor:pointer}
.pg-post-select-checkbox{width:16px;height:16px;cursor:pointer;flex-shrink:0;accent-color:var(--rain-blue)}
.post-number-badge{background:var(--rain-blue);color:#fff;font-size:14px;font-weight:700;padding:4px 8px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,.25);transition:transform .2s,filter .2s;pointer-events:none}
.post-number-badge:hover{transform:translateY(-2px) scale(1.02);filter:brightness(1.1)}
.pg-card-dislike{border:2px solid var(--rain-red)!important;border-radius:8px}
.pg-card-new{border:2px solid var(--rain-green)!important;border-radius:8px}
.pg-badge{display:inline-block;background:var(--light);color:var(--black);border:1px solid #7D7D7D;border-radius:6px;padding:2px 6px;font-size:12px;margin-left:4px}
.pg-visit-summary{color:var(--black);margin-left:6px;font-size:12px}
.pg-btn{font-size:14px;font-weight:600;color:#fff;border:none;border-radius:8px;cursor:pointer;box-shadow:inset 0 -2px 0 rgba(0,0,0,.2);padding:6px 10px;background:var(--desk)}
.pg-btn+.pg-btn{margin-left:6px}
button:disabled{opacity:.6;cursor:not-allowed}
#scrapeStatus{font-size:12px;color:#1A1A1A;min-height:16px}
.post-card.pg-nohover:hover>a{top:0!important;transform:none!important;transition:none!important}
.ad-container,
.blockitsowereplaceit,
.prm-wrapper,
.p-header,
.shareButtons-buttons,
.p-breadcrumbs.p-breadcrumbs--bottom,
.blockMessage.blockMessage--none,
.p-description,
.actionBar-set.actionBar-set--internal,
.reactionsBar.js-reactionsList.is-active,
.p-navEl-link.nav-bonga,
.p-navEl-link.nav-dfake,
.p-navEl-link.nav-tpd,
.ts-outstream-video__video,
#announcement-banner,
.ts-im-container,
#footer,
#footer-about,
.ad-container,
.allow-same-origin.allow-popups.allow-forms.allow-scripts.allow-popups-to-escape-sandbox,
.ts-outstream-video__video,
.ts-outstream-video__video_vertical,
#ad-banner
.leadimage
{display:none!important}
`);



const SPAWN_DELAY = 800;
const imgRE = /\.(jpe?g|png|gif|webp|tiff|bmp|avif)$/i;
const vidRE = /\.(mp4|m4v|mov|wmv|flv|avi|webm|mkv)$/i;
const DEFAULT_POSTS_PER_PAGE = 50;
let PG_POSTS_PER_PAGE = null;
let PG_POSTS_PER_PAGE_KNOWN = false;
let PG_POSTS_PER_PAGE_PROMISE = null;

function updatePostsPerPage(n, { force = false } = {}) {
  if (!n || n <= 0) return;
  if (force) {
    PG_POSTS_PER_PAGE = n;
    PG_POSTS_PER_PAGE_KNOWN = true;
    return;
  }
  if (!PG_POSTS_PER_PAGE_KNOWN) {
    PG_POSTS_PER_PAGE = n;
  } else if (n > PG_POSTS_PER_PAGE) {
    PG_POSTS_PER_PAGE = n;
  }
}

async function ensurePostsPerPage() {
  if (PG_POSTS_PER_PAGE_KNOWN && PG_POSTS_PER_PAGE && PG_POSTS_PER_PAGE > 0) return PG_POSTS_PER_PAGE;

  const stats = getListStats();
  if (stats.pageSize && stats.pageSize > 0) {
    updatePostsPerPage(stats.pageSize, { force: stats.pageReliable });
    if (PG_POSTS_PER_PAGE_KNOWN && PG_POSTS_PER_PAGE && PG_POSTS_PER_PAGE > 0) return PG_POSTS_PER_PAGE;
  }

  if (PG_POSTS_PER_PAGE_PROMISE) return PG_POSTS_PER_PAGE_PROMISE;

  const [, service, , userId] = location.pathname.split('/');
  if (!service || !userId) {
    PG_POSTS_PER_PAGE = PG_POSTS_PER_PAGE && PG_POSTS_PER_PAGE > 0 ? PG_POSTS_PER_PAGE : DEFAULT_POSTS_PER_PAGE;
    return PG_POSTS_PER_PAGE;
  }

  PG_POSTS_PER_PAGE_PROMISE = (async () => {
    const url = `/api/v1/${service}/user/${userId}/posts?o=0&_=${Date.now()}_pp`;
    const resp = await apiGetJson(url);
    const arr = Array.isArray(resp) ? resp : (resp && (resp.results || resp.posts)) || [];
    if (Array.isArray(arr) && arr.length) {
      updatePostsPerPage(arr.length, { force: true });
    }
    if (!PG_POSTS_PER_PAGE || PG_POSTS_PER_PAGE <= 0) {
      PG_POSTS_PER_PAGE = DEFAULT_POSTS_PER_PAGE;
      PG_POSTS_PER_PAGE_KNOWN = false;
    }
    PG_POSTS_PER_PAGE_PROMISE = null;
    return PG_POSTS_PER_PAGE;
  })();

  return PG_POSTS_PER_PAGE_PROMISE;
}

function resolvePagePosition(offset, postsPerPage) {
  let baseOffset = 0;
  if (Array.isArray(PG_PAGE_OFFSETS) && PG_PAGE_OFFSETS.length) {
    for (let i = PG_PAGE_OFFSETS.length - 1; i >= 0; i--) {
      const val = PG_PAGE_OFFSETS[i];
      if (typeof val === 'number' && offset >= val) {
        baseOffset = val;
        return { page: i + 1, local: (offset - val) + 1, baseOffset };
      }
    }
  }
  const size = postsPerPage && postsPerPage > 0 ? postsPerPage : DEFAULT_POSTS_PER_PAGE;
  const page = Math.floor(offset / size) + 1;
  baseOffset = (page - 1) * size;
  return { page, local: (offset % size) + 1, baseOffset };
}
const $ = (s, r = document) => r.querySelector(s);
const $$ = (s, r = document) => [...r.querySelectorAll(s)];
const dataRoot = 'https://' + location.host + '/data';
const userName = () => location.pathname.split('/')[3] || 'user';
let DL_ACTIVE = false;
let MEDIA_MODE = 'all';
let LAST_QUEUE_HAD_ITEMS = false;
let lastFilterParams = {};
const retryMap = Object.create(null);
const MAX_RETRIES = 3;
const BACKOFF_BASE = 1200;
const STALL_IMG_TOTAL_MS = 90000;
const STALL_IMG_IDLE_MS = 45000;
const STALL_VID_TOTAL_MS = 300000;
const STALL_VID_IDLE_MS = 90000;
let HUD_MODE = null;
let HUD_EXTRA = '';
let PG_TOTAL = null;
let PG_GW = 1;
let PG_INDEX_MAP = null;
let PG_INDEX_PROMISE = null;
let PG_PAGE_OFFSETS = [];

function apiGetJson(url) {
  return new Promise(resolve => {
    GM_xmlhttpRequest({
      method: 'GET',
      url,
      headers: {
        Accept: 'text/css',
        Referer: location.href,
        'User-Agent': navigator.userAgent,
        'X-Requested-With': 'XMLHttpRequest'
      },
      onload: resp => {
        if (resp.status >= 200 && resp.status < 300) {
          try { resolve(JSON.parse(resp.responseText)); } catch { resolve(null); }
        } else { resolve(null); }
      },
      onerror: () => resolve(null)
    });
  });
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function setStatus(text, type) {
  const el = $('#filterStatus');
  if (!el) return;
  el.textContent = text || '';
  if (type === 'error') el.style.color = '#b00020';
  else if (type === 'success') el.style.color = '#0a7d2b';
  else el.style.color = '#1A1A1A';
  syncFilterBoxVisibility();
  syncProgressBarVisibility();
}

async function gmSaveText(name, text, saveAs = true) {
  return new Promise(resolve => {
    const dataUrl = 'data:text/plain;charset=utf-8,' + encodeURIComponent(text);
    GM_download({
      url: dataUrl,
      name,
      saveAs,
      onload: () => resolve(true),
      onerror: () => resolve(false)
    });
  });
}



let injectTimer = null;

function debounce(fn, delay) {
  return () => { clearTimeout(injectTimer); injectTimer = setTimeout(fn, delay); };
}

function getListStats() {
  let total = null;
  let offset = 0;
  let pageSize = null;
  let pageReliable = false;
  const params = new URLSearchParams(location.search);
  const o = parseInt(params.get('o') || '0', 10);
  if (!isNaN(o) && o >= 0) offset = o;
  const smalls = document.querySelectorAll('small');
  for (const s of smalls) {
    const t = (s.textContent || '').trim();
    const m = t.match(/Showing\s+(\d+)\s*-\s*(\d+)\s*of\s*(\d+)/i);
    if (m) {
      const start = parseInt(m[1], 10);
      const end = parseInt(m[2], 10);
      const tot = parseInt(m[3], 10);
      if (!isNaN(start) && !isNaN(end) && !isNaN(tot)) {
        total = tot;
        offset = start - 1;
        const span = end - start + 1;
        if (span > 0) {
          pageSize = span;
          if (start === 1 || (tot && (start - 1 + span) < tot)) pageReliable = true;
          updatePostsPerPage(span, { force: pageReliable });
        }
        break;
      }
    }
  }
  return { total, offset, pageSize, pageReliable };
}

function updatePostSelectorFromCheckbox(num, isChecked) {
  const input = $('#fPosts');
  if (!input) return;
  const value = input.value || '';
  const tokens = value.split(',').map(s => s.trim()).filter(Boolean);
  const strNum = String(num);
  const has = tokens.includes(strNum);
  if (isChecked) {
    if (!has) tokens.push(strNum);
  } else {
    if (has) {
      for (let i = tokens.length - 1; i >= 0; i--) {
        if (tokens[i] === strNum) tokens.splice(i, 1);
      }
    }
  }
  let next = tokens.join(', ');
  if (tokens.length) next += ', ';
  input.value = next;
}

function handlePostCheckboxChange(e) {
  const el = e.currentTarget;
  const num = parseInt(el.dataset.pgPostNumber || '', 10);
  if (!num || num <= 0) return;
  updatePostSelectorFromCheckbox(num, el.checked);
}

function injectPostNumbers() {
  document.querySelectorAll('.pg-post-select-wrap, .post-number-badge').forEach(el => el.remove());
  const initialCards = [...document.querySelectorAll('article.post-card')].filter(c => c.style.display !== 'none');
  if (!initialCards.length) return;

  const buildOverlay = (card, n, selectedSet) => {
    if (!n || n <= 0) return;
    const thumb = card.querySelector('.post__thumbnail') || card;
    thumb.style.position = 'relative';
    const wrap = document.createElement('div');
    wrap.className = 'pg-post-select-wrap';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.className = 'pg-post-select-checkbox';
    cb.dataset.pgPostNumber = String(n);
    if (selectedSet.has(n)) cb.checked = true;
    cb.addEventListener('change', handlePostCheckboxChange);
    cb.addEventListener('pointerdown', e => {
      e.preventDefault();
      e.stopPropagation();
      const num = parseInt(cb.dataset.pgPostNumber || '', 10);
      if (!num || num <= 0) return;
      const next = !cb.checked;
      cb.checked = next;
      updatePostSelectorFromCheckbox(num, next);
    });
    cb.addEventListener('click', e => {
      e.preventDefault();
      e.stopPropagation();
    });
    wrap.addEventListener('pointerdown', e => {
      if (e.target === cb) return;
      e.preventDefault();
      e.stopPropagation();
      const num = parseInt(cb.dataset.pgPostNumber || '', 10);
      if (!num || num <= 0) return;
      const next = !cb.checked;
      cb.checked = next;
      updatePostSelectorFromCheckbox(num, next);
    });
    wrap.addEventListener('click', e => {
      e.preventDefault();
      e.stopPropagation();
    });
    wrap.addEventListener('mouseenter', () => {
      card.classList.add('pg-nohover');
    });
    wrap.addEventListener('mouseleave', () => {
      card.classList.remove('pg-nohover');
    });
    const badge = document.createElement('div');
    badge.className = 'post-number-badge';
    badge.textContent = n > 0 ? n : '';
    wrap.appendChild(cb);
    wrap.appendChild(badge);
    thumb.appendChild(wrap);
  };

  const parts = location.pathname.split('/');
  const service = parts[1];
  const userId = parts[3];

  if (service && userId) {
    ensureGlobalIndexMap().then(map => {
      const cards = [...document.querySelectorAll('article.post-card')].filter(c => c.style.display !== 'none');
      if (!cards.length) return;
      let selectedSet = new Set();
      const postsInput = $('#fPosts');
      if (postsInput && postsInput.value && postsInput.value.trim()) {
        const parsed = parseIndices(postsInput.value);
        if (parsed && parsed.size) selectedSet = parsed;
      }
      if (!map || !map.size) {
        const stats = getListStats();
        if (!stats.total || stats.total <= 0) return;
        cards.forEach((card, i) => {
          const n = stats.total - (stats.offset + i);
          buildOverlay(card, n, selectedSet);
        });
        return;
      }
      cards.forEach(card => {
        const id = card.getAttribute('data-id');
        if (!id) return;
        const n = map.get(String(id));
        if (!n || n <= 0) return;
        buildOverlay(card, n, selectedSet);
      });
    });
  } else {
    const stats = getListStats();
    if (!stats.total || stats.total <= 0) return;
    let selectedSet = new Set();
    const postsInput = $('#fPosts');
    if (postsInput && postsInput.value && postsInput.value.trim()) {
      const parsed = parseIndices(postsInput.value);
      if (parsed && parsed.size) selectedSet = parsed;
    }
    initialCards.forEach((card, i) => {
      const n = stats.total - (stats.offset + i);
      buildOverlay(card, n, selectedSet);
    });
  }
}

function syncProgressHUDSize() {
  const w = $('#partyHUD');
  const p = $('#progressHUD');
  if (!w || !p) return;
  const barRect = w.getBoundingClientRect();
  const dl = $('#dlBtn');
  let left = 8;
  if (dl) {
    const dlRect = dl.getBoundingClientRect();
    left = Math.max(8, Math.round(dlRect.left));
  }
  const gap = 10;
  const barHeight = Math.max(0, Math.round(window.innerHeight - barRect.top));
  p.style.left = left + 'px';
  p.style.right = 'auto';
  p.style.bottom = (barHeight + gap) + 'px';
}

function syncFilterBoxWidth(){
  const bar = document.getElementById('partyHUD');
  const post = document.getElementById('fPosts');
  if (!bar || !post) return;
  const b = bar.getBoundingClientRect();
  const p = post.getBoundingClientRect();
  const w = Math.max(0, Math.round(p.right - b.left));
  bar.style.setProperty('--hud-row-width', w + 'px');
}

function syncFilterBoxVisibility(){
  const box = document.getElementById('filterBox');
  const status = document.getElementById('filterStatus');
  if (!box || !status) return;
  const hasText = !!(status.textContent && status.textContent.trim());
  const { total, completed, downloading, queued } = getCounts();
  const hasActivity = (total + completed + downloading + queued + lastDropNoteCount) > 0 || HUD_MODE === 'scrape';
  box.style.display = hasText || hasActivity ? 'inline-flex' : 'none';
}

function syncProgressBarVisibility(){
  const wrap = document.getElementById('pgWrap');
  if (!wrap) return;
  const { total, completed, downloading, queued } = getCounts();
  const hasActivity = (total + completed + downloading + queued + lastDropNoteCount) > 0 || HUD_MODE === 'scrape';
  wrap.style.display = hasActivity ? 'flex' : 'none';
}

function lockMediaButtonWidth(){
  const btn = document.getElementById('btnMedia');
  if (!btn) return;
  const labels = ['All','Images','GIFs','Videos'];
  const probe = btn.cloneNode(true);
  probe.style.position = 'absolute';
  probe.style.visibility = 'hidden';
  probe.style.left = '-9999px';
  probe.style.width = 'auto';
  probe.style.whiteSpace = 'nowrap';
  document.body.appendChild(probe);
  let max = 0;
  for (const t of labels){
    probe.textContent = t;
    max = Math.max(max, probe.offsetWidth);
  }
  document.body.removeChild(probe);
  btn.style.width = max + 'px';
}

function buildHUD() {
  if ($('#partyHUD')) return;

  const w = document.createElement('div');
  w.id = 'partyHUD';
  w.innerHTML = `
    <div id="filterBox">
      <span id="filterStatus"></span>
      <div id="pgRight" aria-live="polite">
        <div id="pgMini">
          <span>Completed: <span id="completedCount">0</span></span>
          <span class="pgDot">•</span>
          <span>Queued: <span id="queuedCount">0</span></span>
        </div>
        <div id="pgDrop" style="display:none">
          <span class="pgDot">•</span>
          <span>Dropped: <span id="droppedCount">0</span></span>
        </div>
      </div>
    </div>
    <div id="pgWrap" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Download progress">
      <div id="pgTrack"><div id="pgFill"></div></div>
      <div id="pgBarLabel" aria-hidden="true">0%</div>
    </div>
    <div id="hudRow" class="hud-row">
      <button id="dlBtn" class="full">Download</button>
      <button id="scrapeBtn" class="full">Scrape</button>
      <button id="filterBtn" class="full">Preview</button>
      <button id="btnMedia" class="full">All</button>
      <input id="fPages" type="text" placeholder="Page">
      <input id="fPosts" type="text" placeholder="Post">
      <input id="fMaxDur" type="number" placeholder="Max duration" min="1" step="1">
      <input id="fMinDur" type="number" placeholder="Min duration" min="1" step="1">
      <input id="fMaxAtt" type="number" placeholder="Max attachments" min="1" step="1">
      <input id="fMinAtt" type="number" placeholder="Min attachments" min="1" step="1">
    </div>
  `;
  document.body.appendChild(w);

  $('#dlBtn').onclick = handleDlBtn;
  $('#filterBtn').onclick = handleFilterOnly;
  $('#scrapeBtn').onclick = handleScrape;

  const mediaLabel = m => m === 'all' ? 'All' : m === 'images' ? 'Images' : m === 'gifs' ? 'GIFs' : m === 'videos' ? 'Videos' : 'All';
  const btnMedia = $('#btnMedia');
  btnMedia.textContent = mediaLabel(MEDIA_MODE);
  btnMedia.onclick = () => {
    MEDIA_MODE =
      MEDIA_MODE === 'all' ? 'images' :
      MEDIA_MODE === 'images' ? 'gifs' :
      MEDIA_MODE === 'gifs' ? 'videos' :
      'all';
    btnMedia.textContent = mediaLabel(MEDIA_MODE);
  };

  const hudRow = document.getElementById('hudRow');
  if (hudRow && 'ResizeObserver' in window) {
    new ResizeObserver(() => { syncFilterBoxWidth(); }).observe(hudRow);
  }
  requestAnimationFrame(syncFilterBoxWidth);
  requestAnimationFrame(syncFilterBoxVisibility);
  requestAnimationFrame(syncProgressBarVisibility);
  requestAnimationFrame(lockMediaButtonWidth);
}

function allowedUrl(u) {
  const s = (u || '').split('?')[0];
  const isImg = imgRE.test(s), isVid = vidRE.test(s);
  const isGif = s.toLowerCase().endsWith('.gif');
  const isAbs = /^https?:\/\//i.test(s);
  if (MEDIA_MODE === 'all') return isImg || isVid;
  if (MEDIA_MODE === 'images') return isImg;
  if (MEDIA_MODE === 'gifs') return isGif;
  if (MEDIA_MODE === 'videos') return isVid;
  return false;
}

function resolveFileUrl(obj) {
  if (!obj) return null;
  if (obj.path) {
    const p = obj.path.startsWith('/') ? obj.path : ('/' + obj.path);
    if (obj.path.startsWith('http')) return obj.path;
    return dataRoot + p;
  }
  if (obj.url && obj.url.startsWith('http')) return obj.url;
  return null;
}

const durCache = Object.create(null);

function getVideoDuration(u) {
  return durCache[u] ?? (durCache[u] = new Promise(res => {
    const v = document.createElement('video');
    v.preload = 'metadata';
    v.crossOrigin = 'anonymous';
    v.src = u;
    const done = d => { try{v.remove();}catch{} try{v.src='';}catch{} res(d); };
    v.onloadedmetadata = () => done(v.duration || Infinity);
    v.onerror = () => done(Infinity);
  }));
}

async function videoBelowDuration(u, maxSec) {
  const d = await getVideoDuration(u);
  return d <= maxSec;
}



const dl = { items: [], started: false, dispatching: false };
const cooldownTimers = new Map();

function parLimit() { return 5; }

function getCounts() {
  let total = dl.items.length, completed = 0, downloading = 0, queued = 0;
  for (const it of dl.items) {
    if (it.status === 'done') completed++;
    else if (it.status === 'active') downloading++;
    else if (it.status === 'queued') queued++;
  }
  return { total, completed, downloading, queued };
}

let uiScheduled = false;
let lastDropNoteAt = 0;
let lastDropNoteCount = 0;

function updateHUD() {
  if (!uiScheduled) return;
  uiScheduled = false;

  const { total, completed, downloading, queued } = getCounts();
  const percent = total ? Math.round((completed / total) * 100) : 0;
  const pct = Math.max(0, Math.min(100, percent));

  const fill = $('#pgFill'); if (fill) fill.style.width = pct + '%';
  const barLabel = $('#pgBarLabel'); if (barLabel) barLabel.textContent = pct + '%';
  const pgWrap = $('#pgWrap'); if (pgWrap) pgWrap.setAttribute('aria-valuenow', String(pct));

  const cC = $('#completedCount'); if (cC) cC.textContent = completed;
  const qC = $('#queuedCount'); if (qC) qC.textContent = queued;

  const hasDropped = lastDropNoteCount > 0;
  const dropEl = $('#pgDrop'); if (dropEl) dropEl.style.display = hasDropped ? 'flex' : 'none';
  const xC = $('#droppedCount'); if (xC) xC.textContent = String(lastDropNoteCount);

  syncFilterBoxVisibility();
  syncProgressBarVisibility();
}

function scheduleHUD() {
  if (uiScheduled) return;
  uiScheduled = true;
  requestAnimationFrame(updateHUD);
}

function requestDispatch() {
  if (dl.dispatching) return;
  dl.dispatching = true;
  queueMicrotask(() => {
    try {
      if (!dl.started) return;
      let startedAny = false;
      while (activeCount() < parLimit()) {
        const it = claimNext();
        if (!it) break;
        startedAny = true;
        startDownload(it);
      }
      if (startedAny) scheduleHUD();
    } finally {
      dl.dispatching = false;
      if (dl.started && hasRunnableQueued() && activeCount() < parLimit()) requestDispatch();
    }
  });
}

function activeCount() {
  let n = 0;
  for (const it of dl.items) if (it.status === 'active') n++;
  return n;
}

function hasRunnableQueued() {
  const now = Date.now();
  for (const it of dl.items) if (it.status === 'queued' && now >= (it.nextAt || 0)) return true;
  return false;
}

function claimNext() {
  const now = Date.now();
  for (const it of dl.items) {
    if (it.status === 'queued' && now >= (it.nextAt || 0)) { it.status = 'active'; return it; }
  }
  return null;
}

function enqueueItems(objs) {
  const toAdd = [];
  for (const obj of objs) {
    const url = obj.url;
    const name = obj.name;
    const meta = obj.meta || null;
    toAdd.push({ url, name, meta, status: 'queued', attempts: 0, nextAt: 0 });
  }
  if (!toAdd.length) return;
  dl.items.push(...toAdd);
  scheduleHUD();
  if (dl.started) requestDispatch();
}

function maybeFinishBatch() {
  const { total, completed, downloading, queued } = getCounts();
  if (total > 0 && completed === total && downloading === 0 && queued === 0) {
    DL_ACTIVE = false;
    dl.started = false;
    const b = $('#dlBtn'); if (b) { b.classList.remove('stop'); b.textContent = 'Download'; }
  }
}

function startDownload(item) {
  const name = item.name;
  const isVid = vidRE.test(item.url);
  const totalMs = isVid ? STALL_VID_TOTAL_MS : STALL_IMG_TOTAL_MS;
  const idleMs = isVid ? STALL_VID_IDLE_MS : STALL_IMG_IDLE_MS;
  let lastProgressAt = Date.now();
  let settled = false;

  const clearWatchers = () => { try { clearTimeout(tTotal); } catch {} try { clearInterval(tIdle); } catch {} };

  const handleFailure = () => {
    if (settled) return;
    settled = true;
    try { if (item._handle && typeof item._handle.abort === 'function') item._handle.abort(); } catch {}
    clearWatchers();
    const n = (retryMap[item.url] || 0) + 1;
    retryMap[item.url] = n;
    if (n <= MAX_RETRIES) {
      const backoff = BACKOFF_BASE * Math.pow(2, n - 1) + Math.floor(Math.random() * 500);
      item.status = 'queued';
      item.nextAt = Date.now() + backoff;
      const prev = cooldownTimers.get(item.url);
      if (prev) clearTimeout(prev);
      const tid = setTimeout(() => { item.nextAt = 0; scheduleHUD(); if (dl.started) requestDispatch(); }, backoff + 5);
      cooldownTimers.set(item.url, tid);
      scheduleHUD();
      setTimeout(requestDispatch, 0);
    } else {
      const idx = dl.items.indexOf(item);
      if (idx >= 0) dl.items.splice(idx, 1);
      lastDropNoteAt = Date.now();
      lastDropNoteCount++;
      scheduleHUD();
      setTimeout(requestDispatch, SPAWN_DELAY + Math.floor(Math.random() * 200));
      maybeFinishBatch();
    }
  };

  const tTotal = setTimeout(() => handleFailure(), totalMs);
  const tIdle = setInterval(() => {
    if (Date.now() - lastProgressAt > idleMs) handleFailure();
  }, 2000);

  const handle = GM_download({
    url: item.url,
    name,
    headers: { Referer: location.href, Accept: 'text/css' },
    timeout: 0,
    onprogress: () => { lastProgressAt = Date.now(); },
    onload: () => {
      if (settled) return;
      settled = true;
      clearWatchers();
      item.status = 'done';
      scheduleHUD();
      setTimeout(requestDispatch, SPAWN_DELAY + Math.floor(Math.random() * 200));
      maybeFinishBatch();
    },
    onerror: () => handleFailure()
  });
  item._handle = handle;
}



function parsePages(str) {
  const set = new Set();
  if (!str.trim()) return null;
  str.split(',').forEach(p => {
    if (p.includes('-')) {
      const [a, b] = p.split('-').map(Number);
      if (!a || !b || a <= 0 || b < a) return;
      for (let i = a; i <= b; i++) set.add(i);
    } else {
      const n = parseInt(p, 10);
      if (!n || n <= 0) return;
      set.add(n);
    }
  });
  return set.size ? [...set].sort((a, b) => a - b) : null;
}

function parseIndices(str) {
  const set = new Set();
  if (!str.trim()) return null;
  const tokens = str.split(',').map(s=>s.trim()).filter(Boolean);
  for (const token of tokens){
    if (token.includes('-')) {
      const [a, b] = token.split('-').map(Number);
      if (!a || !b || a <= 0 || b < a) continue;
      for (let i=a;i<=b;i++) set.add(i);
    } else {
      const n = parseInt(token, 10);
      if (!n || n <= 0) continue;
      set.add(n);
    }
  }
  return set.size ? new Set([...set].sort((a, b) => a - b)) : new Set();
}



const slug = s => (s || 'untitled').trim().replace(/[\s\\/:*?"<>|]+/g, '_').slice(0, 60);

function formatFilename(post, fileObj, index, globalIndex) {
  const user = post.user || userName();
  const sanitizeSection = s => {
    s = (s || '').normalize('NFC');
    s = s.replace(/\s+/g, '_');
    s = s.replace(/[\\/:*?"<>|]+/g, '');
    s = s.replace(/[\x00-\x1F\x7F]/g, '');
    s = s.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
    return s;
  };
  const titleRaw = (post.title && post.title.trim()) ? post.title : ('post_' + post.id);
  const userSec = sanitizeSection(user);
  const titleSec = sanitizeSection(titleRaw).slice(0, 60);
  const idx = String(index).padStart(2, '0');
  const ext = (fileObj.name || fileObj.path || '').split('.').pop().split('?')[0].toLowerCase();
  const g = String(globalIndex || 0).padStart(PG_GW || 1, '0');
  return `${userSec} - ${g} - ${titleSec}_${idx}.${ext}`;
}

function extractLinksFromPost(p) {
  const html = p.content || p.body || p.description || p.text || p.message || p.commentary || p.plain || p.excerpt || p.snippet || p.substring || '';
  if (typeof html !== 'string' || !html.trim()) return [];
  let out = [];
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    doc.querySelectorAll('a[href]').forEach(a => {
      const href = a.getAttribute('href') || '';
      if (/^https?:\/\//i.test(href)) out.push(href);
    });
  } catch {}
  return out;
}



let keptPosts = [];

async function enumerateAllPostIds(service, userId) {
  const ids = [];
  let offset = 0;
  let pageIndex = 0;
  while (true) {
    const apiUrl = `/api/v1/${service}/user/${userId}/posts?o=${offset}`;
    const resp = await apiGetJson(apiUrl);
    const arr = Array.isArray(resp) ? resp : (resp && (resp.results || resp.posts)) || [];
    if (!Array.isArray(arr) || arr.length === 0) break;
    if (PG_PAGE_OFFSETS.length === pageIndex) PG_PAGE_OFFSETS.push(offset);
    else PG_PAGE_OFFSETS[pageIndex] = offset;
    updatePostsPerPage(arr.length, { force: !PG_POSTS_PER_PAGE_KNOWN });
    for (const p of arr) ids.push(String(p.id));
    offset += arr.length;
    pageIndex++;
    await sleep(200 + Math.floor(Math.random()*200));
  }
  return ids;
}

async function ensureGlobalIndexMap() {
  if (PG_INDEX_MAP) return PG_INDEX_MAP;
  if (PG_INDEX_PROMISE) return PG_INDEX_PROMISE;
  const parts = location.pathname.split('/');
  const service = parts[1];
  const userId = parts[3];
  if (!service || !userId) return null;
  PG_INDEX_PROMISE = (async () => {
    PG_PAGE_OFFSETS = [];
    const ids = await enumerateAllPostIds(service, userId);
    if (!ids || !ids.length) {
      PG_TOTAL = null;
      PG_GW = 1;
      PG_INDEX_MAP = null;
      return null;
    }
    const total = ids.length;
    PG_TOTAL = total;
    PG_GW = String(total).length;
    const map = new Map();
    for (let i = 0; i < ids.length; i++) {
      const n = total - i;
      map.set(String(ids[i]), n);
    }
    PG_INDEX_MAP = map;
    return map;
  })();
  const result = await PG_INDEX_PROMISE;
  PG_INDEX_PROMISE = null;
  return result;
}

async function handleFilter() {
  const st = $('#filterStatus');
  if (st) st.textContent = '';

  const pagesRaw = $('#fPages')?.value || '';
  const postsRaw = $('#fPosts')?.value || '';
  const maxDurRaw = $('#fMaxDur')?.value || '';
  const minDurRaw = $('#fMinDur')?.value || '';
  const maxAttRaw = $('#fMaxAtt')?.value || '';
  const minAttRaw = $('#fMinAtt')?.value || '';
  const globalPosts = parseIndices(postsRaw);
  if (postsRaw.trim() && (!globalPosts || globalPosts.size === 0)) { if (st) st.textContent = 'Invalid posts'; scheduleHUD(); return; }
  const filteringByPosts = globalPosts && globalPosts.size;

  let maxDurSec = null, minDurSec = null;
  if (maxDurRaw.trim()) {
    const s = parseFloat(maxDurRaw);
    if (isNaN(s) || s <= 0) { if (st) st.textContent = 'Invalid duration'; scheduleHUD(); return; }
    maxDurSec = s;
  }
  if (minDurRaw.trim()) {
    const s2 = parseFloat(minDurRaw);
    if (isNaN(s2) || s2 <= 0) { if (st) st.textContent = 'Invalid duration'; scheduleHUD(); return; }
    minDurSec = s2;
  }
  if (maxDurSec != null && minDurSec != null && minDurSec > maxDurSec) { if (st) st.textContent = 'Min exceeds Max'; scheduleHUD(); return; }

  let maxAtt = null, minAtt = null;
  if (maxAttRaw.trim()) {
    const n = parseInt(maxAttRaw, 10);
    if (isNaN(n) || n <= 0) { if (st) st.textContent = 'Invalid attachments'; scheduleHUD(); return; }
    maxAtt = n;
  }
  if (minAttRaw.trim()) {
    const n2 = parseInt(minAttRaw, 10);
    if (isNaN(n2) || n2 <= 0) { if (st) st.textContent = 'Invalid attachments'; scheduleHUD(); return; }
    minAtt = n2;
  }
  if (maxAtt != null && minAtt != null && minAtt > maxAtt) { if (st) st.textContent = 'Min exceeds Max'; scheduleHUD(); return; }

  const stats0 = getListStats();
  let postsPerPage = Math.max(await ensurePostsPerPage(), 1);

  keptPosts = [];

  const [, service, , userId] = location.pathname.split('/');
  let indexMap = null;
  if (service && userId) {
    indexMap = await ensureGlobalIndexMap();
    if (indexMap && indexMap.size) {
      PG_TOTAL = indexMap.size;
      PG_GW = String(PG_TOTAL).length;
    } else if (stats0.total && stats0.total > 0) {
      PG_TOTAL = stats0.total;
      PG_GW = String(PG_TOTAL).length;
    } else {
      PG_TOTAL = null;
      PG_GW = 1;
    }
  } else {
    if (stats0.total && stats0.total > 0) {
      PG_TOTAL = stats0.total;
      PG_GW = String(PG_TOTAL).length;
    } else {
      PG_TOTAL = null;
      PG_GW = 1;
    }
  }

  lastFilterParams = { postRaw: postsRaw, service, media: MEDIA_MODE, maxDurRaw, minDurRaw, maxAttRaw, minAttRaw };

  const allowed = new Set();
  let totalFiles = 0;

  let perPageMap = null;
  let pages = null, allPages = false;

  if (filteringByPosts) {
    const total = PG_TOTAL;
    if (!total || total <= 0) { if (st) st.textContent = 'Unable to resolve total posts'; scheduleHUD(); return; }

    perPageMap = new Map();
    let dropped = 0;
    [...globalPosts].forEach(n => {
      if (n < 1 || n > total) { dropped++; return; }
      const offset = total - n;
      const pos = resolvePagePosition(offset, postsPerPage);
      const page = pos.page;
      const local = pos.local;
      if (!perPageMap.has(page)) perPageMap.set(page, new Set());
      perPageMap.get(page).add(local);
    });
    if (dropped && st) st.textContent = `Ignored ${dropped} invalid indices`;

    const derivedPages = [...perPageMap.keys()].sort((a,b)=>a-b);

    if (!pagesRaw.trim()) {
      pages = derivedPages;
    } else {
      const userPages = parsePages(pagesRaw);
      if (!userPages) { if (st) st.textContent = 'Invalid pages'; scheduleHUD(); return; }
      const userSet = new Set(userPages);
      pages = derivedPages.filter(p => userSet.has(p));
      if (!pages.length) { if (st) st.textContent = 'No matching pages for given posts'; scheduleHUD(); return; }
    }
  } else {
    if (!pagesRaw.trim()) {
      allPages = true;
    } else {
      pages = parsePages(pagesRaw);
      if (!pages) { if (st) st.textContent = 'Invalid pages'; scheduleHUD(); return; }
    }
  }

  const allIdsPartial = [];
  const procPage = async pg => {
    setStatus('Fetching page ' + pg, 'info');
    try {
      const storedOffset = PG_PAGE_OFFSETS[pg - 1];
      const pageOffset = typeof storedOffset === 'number' ? storedOffset : (pg - 1) * postsPerPage;
      const url = `/api/v1/${service}/user/${userId}/posts?o=${pageOffset}&_=${Date.now()}_${pg}`;
      const apiResp = await apiGetJson(url);
      const arr = Array.isArray(apiResp) ? apiResp : (apiResp && (apiResp.results || apiResp.posts)) || [];
      if (!Array.isArray(arr) || arr.length === 0) return false;

      updatePostsPerPage(arr.length, { force: !PG_POSTS_PER_PAGE_KNOWN });
      if (PG_POSTS_PER_PAGE_KNOWN && PG_POSTS_PER_PAGE && PG_POSTS_PER_PAGE > 0) {
        postsPerPage = PG_POSTS_PER_PAGE;
      } else if (arr.length > 0 && arr.length !== postsPerPage) {
        postsPerPage = arr.length;
      }

      for (const p of arr) allIdsPartial.push(String(p.id));

      for (const [i, p] of arr.entries()) {
        if (filteringByPosts) {
          const need = perPageMap && perPageMap.get(pg);
          if (!need || !need.has(i + 1)) continue;
        }

        let refs = [];
        const add = o => { const u = resolveFileUrl(o); if (u) refs.push(u); };
        if (p.file) add(p.file);
        if (p.attachments) p.attachments.forEach(add);

        const seen = new Set();
        const uniqRefs = [];
        for (const ref of refs) {
          const key = (ref.split('?')[0] || '').toLowerCase();
          if (seen.has(key)) continue;
          seen.add(key);
          uniqRefs.push(ref);
        }

        const allowedFiles = [];
        for (const ref of uniqRefs) {
          if (!allowedUrl(ref)) continue;
          if (vidRE.test(ref) && (maxDurSec != null || minDurSec != null)) {
            const d = await getVideoDuration(ref);
            if (!isFinite(d)) continue;
            if (minDurSec != null && d < minDurSec) continue;
            if (maxDurSec != null && d > maxDurSec) continue;
          }
          allowedFiles.push(ref);
        }
        if (!allowedFiles.length) continue;

        if (minAtt != null && allowedFiles.length < minAtt) continue;
        if (maxAtt != null && allowedFiles.length > maxAtt) continue;

        const gi = (PG_TOTAL && PG_TOTAL > 0) ? (PG_TOTAL - (pageOffset + i)) : null;

        allowed.add(String(p.id));
        keptPosts.push({ post: p, allowedFiles, globalIndex: gi });
        totalFiles += allowedFiles.length;
      }

      if (typeof PG_PAGE_OFFSETS[pg] === 'number') return true;
      return arr.length === postsPerPage;
    } catch {
      return false;
    }
  };

  if (allPages) {
    let pg = 1;
    while (await procPage(pg++)) { }
  } else {
    for (const pg of pages) await procPage(pg);
  }

  let needMap = keptPosts.some(kp => !kp.globalIndex);
  if (allPages && !indexMap) {
    if (allIdsPartial.length > 0) {
      PG_TOTAL = allIdsPartial.length;
      PG_GW = String(PG_TOTAL).length;
      const map = new Map();
      for (let i=0;i<allIdsPartial.length;i++) map.set(allIdsPartial[i], PG_TOTAL - i);
      for (const kp of keptPosts) if (!kp.globalIndex) kp.globalIndex = map.get(String(kp.post.id)) || 0;
      needMap = false;
    }
  }
  if (needMap && indexMap) {
    for (const kp of keptPosts) if (!kp.globalIndex) kp.globalIndex = indexMap.get(String(kp.post.id)) || 0;
    needMap = false;
  }
  if (needMap && service && userId && !indexMap) {
    const ids = await enumerateAllPostIds(service, userId);
    if (ids && ids.length) {
      PG_TOTAL = ids.length;
      PG_GW = String(PG_TOTAL).length;
      const map = new Map();
      for (let i=0;i<ids.length;i++) map.set(ids[i], PG_TOTAL - i);
      for (const kp of keptPosts) if (!kp.globalIndex) kp.globalIndex = map.get(String(kp.post.id)) || 0;
    }
  }

  $$('article.post-card').forEach(c => {
    const id = c.getAttribute('data-id');
    c.style.display = allowed.has(id) ? '' : 'none';
  });

  if (st) st.textContent = 'Showing ' + keptPosts.length + ' posts and ' + totalFiles + ' files';
  injectPostNumbers();
  scheduleHUD();
}

async function handleFilterOnly() { await handleFilter(); }

async function queueFiltered() {
  if (!keptPosts.length) return;
  const objs = [];
  keptPosts.forEach(kp => {
    const { post, allowedFiles, globalIndex } = kp;
    let idx = 1;
    allowedFiles.forEach(ref => {
      const fileObj = { path: ref };
      const name = formatFilename(post, fileObj, idx++, globalIndex);
      objs.push({ url: ref, name, meta: { post, index: idx - 1, url: ref, globalIndex } });
    });
  });
  if (!objs.length) {
    const st = $('#filterStatus');
    if (st) st.textContent = 'No files matched your filters.';
    scheduleHUD();
    return;
  }
  LAST_QUEUE_HAD_ITEMS = true;
  enqueueItems(objs);
}



async function handleScrape() {
  const btn = $('#scrapeBtn');
  btn.disabled = true;
  setStatus('Preparing...','info');

  const parts = location.pathname.split('/');
  const service = parts[1];
  const userId  = parts[3];

  if (!service || !userId) {
    setStatus('Go to a user page first (e.g., /{service}/user/{userId}).','error');
    btn.disabled = false;
    return;
  }

  const all = [];
  let pg = 1;
  let postsPerPage = Math.max(await ensurePostsPerPage(), 1);
  let offset = 0;

  while (true) {
    setStatus(`Fetching page ${pg}...`,'info');

    const apiUrl = `/api/v1/${service}/user/${userId}/posts?o=${offset}`;
    const resp = await apiGetJson(apiUrl);
    const arr = Array.isArray(resp) ? resp : (resp && (resp.results || resp.posts)) || [];

    if (!Array.isArray(arr) || arr.length === 0) break;
    updatePostsPerPage(arr.length, { force: !PG_POSTS_PER_PAGE_KNOWN });
    if (PG_POSTS_PER_PAGE_KNOWN && PG_POSTS_PER_PAGE && PG_POSTS_PER_PAGE > 0) {
      postsPerPage = PG_POSTS_PER_PAGE;
    } else if (arr.length > 0 && arr.length !== postsPerPage) {
      postsPerPage = arr.length;
    }
    all.push(...arr);
    offset += arr.length;

    if (typeof PG_PAGE_OFFSETS[pg] === 'number') {
      offset = PG_PAGE_OFFSETS[pg];
    }

    if ((typeof PG_PAGE_OFFSETS[pg] !== 'number') && arr.length < postsPerPage) break;

    pg++;
    await sleep(300 + Math.floor(Math.random()*400));
  }

  if (!all.length) {
    setStatus('No posts found to scrape.','error');
    btn.disabled = false;
    return;
  }

  const ndjson = all.map(o=>JSON.stringify(o)).join('\n');
  const now = new Date();
  const y = String(now.getFullYear());
  const M = String(now.getMonth()+1).padStart(2,'0');
  const D = String(now.getDate()).padStart(2,'0');
  const h = String(now.getHours()).padStart(2,'0');
  const m = String(now.getMinutes()).padStart(2,'0');
  const s = String(now.getSeconds()).padStart(2,'0');
  const base = `${service}_${userId}_${y}${M}${D}${h}${m}${s}_posts`;
  const mainName = `${base}.txt`;

  setStatus(`Saving ${all.length} posts...`,'info');
  const ok = await gmSaveText(mainName, ndjson, true);

  if (ok) {
    setStatus(`Saved ${mainName} (${all.length} posts).`,'success');
    btn.disabled = false;
    return;
  }

  const TARGET = 700000;
  const lines = ndjson.split('\n');
  const partsOut = [];
  let buf = [];
  let charCount = 0;

  for (let i=0;i<lines.length;i++){
    const line = lines[i];
    const add = line.length + 1;
    if (charCount + add > TARGET && buf.length){
      partsOut.push(buf.join('\n'));
      buf = [];
      charCount = 0;
    }
    buf.push(line);
    charCount += add;
  }
  if (buf.length) partsOut.push(buf.join('\n'));

  let success = 0;
  for (let i=0;i<partsOut.length;i++){
    const name = `${base}_part${String(i+1).padStart(2,'0')}.txt`;
    const okPart = await gmSaveText(name, partsOut[i], true);
    if (okPart) success++;
    await sleep(120);
  }

  if (success>0){
    setStatus(`Saved ${success}/${partsOut.length} part(s) (${all.length} posts).`,'success');
  } else {
    setStatus('Failed to save scrape output.','error');
  }
  btn.disabled = false;
}



async function handleQueue() {
  await handleFilter();
  await queueFiltered();
  scheduleHUD();
}

async function handleClear() {
  const b = $('#dlBtn');
  dl.started = false;
  DL_ACTIVE = false;
  if (b) { b.classList.remove('stop'); b.textContent = 'Download'; }
  cooldownTimers.forEach(id => clearTimeout(id));
  cooldownTimers.clear();
  for (const k in retryMap) delete retryMap[k];
  lastDropNoteAt = 0;
  lastDropNoteCount = 0;
  dl.items.length = 0;
  const cC = $('#completedCount'); if (cC) cC.textContent = '0';
  const qC = $('#queuedCount'); if (qC) qC.textContent = '0';
  const xC = $('#droppedCount'); if (xC) xC.textContent = '0';
  const dropEl = $('#pgDrop'); if (dropEl) dropEl.style.display = 'none';
  const fill = $('#pgFill'); if (fill) fill.style.width = '0%';
  const barLabel = $('#pgBarLabel'); if (barLabel) barLabel.textContent = '0%';
  injectPostNumbers();
  scheduleHUD();
}

async function handleDlBtn() {
  const b = $('#dlBtn');

  if (!DL_ACTIVE) {
    const c = getCounts();
    if (c.total > 0 && c.completed === c.total && c.downloading === 0 && c.queued === 0) {
      await handleClear();
    }

    if (dl.items.length > 0) {
      DL_ACTIVE = true;
      dl.started = true;
      b.classList.add('stop');
      b.textContent = 'Stop';
      requestDispatch();
      scheduleHUD();
      return;
    }

    dl.started = false;
    DL_ACTIVE = false;
    LAST_QUEUE_HAD_ITEMS = false;
    keptPosts = [];
    lastFilterParams = {};
    for (const k in retryMap) delete retryMap[k];
    cooldownTimers.forEach(id => clearTimeout(id));
    cooldownTimers.clear();
    dl.items.length = 0;
    lastDropNoteAt = 0;
    lastDropNoteCount = 0;
    const st = $('#filterStatus'); if (st) st.textContent = '';
    const fill = $('#pgFill'); if (fill) fill.style.width = '0%';
    const barLabel = $('#pgBarLabel'); if (barLabel) barLabel.textContent = '0%';
    const cC = $('#completedCount'); if (cC) cC.textContent = '0';
    const qC = $('#queuedCount'); if (qC) qC.textContent = '0';
    const dropEl = $('#pgDrop'); if (dropEl) dropEl.style.display = 'none';
    const xC = $('#droppedCount'); if (xC) xC.textContent = '0';
    await handleFilter();
    await queueFiltered();

    if (LAST_QUEUE_HAD_ITEMS) {
      DL_ACTIVE = true;
      dl.started = true;
      b.classList.add('stop');
      b.textContent = 'Stop';
      requestDispatch();
      scheduleHUD();
    } else {
      DL_ACTIVE = false;
      dl.started = false;
      b.classList.remove('stop');
      b.textContent = 'Download';
      scheduleHUD();
    }
  } else {
    dl.started = false;
    DL_ACTIVE = false;
    b.classList.remove('stop');
    b.textContent = 'Download';
    scheduleHUD();
  }
}



function pgUserKey(slug) { return 'pg_u_' + slug; }

function pgExtractSummary(url, orUser) {
  const m = (url || '').match(/\/user\/([^/]+)/);
  if (m) {
    const k = pgUserKey(m[1]);
    let s = null;
    try { s = JSON.parse(localStorage.getItem(k) || 'null'); } catch { }
    if (s && !s.user) s.user = m[1];
    return s ? s : (orUser ? m[1] : s);
  }
  return false;
}

function pgLoadSummary(slug) {
  const k = pgUserKey(slug);
  try { return JSON.parse(localStorage.getItem(k) || 'null'); } catch { return null; }
}

function pgSaveSummary(slug, obj) {
  const k = pgUserKey(slug);
  try { localStorage.setItem(k, JSON.stringify(obj)); } catch { }
}

function pgTodayISO() { return new Date().toISOString().split('T')[0]; }

function pgEnsureVisit(slug) {
  let s = pgLoadSummary(slug);
  const today = pgTodayISO();

  if (!s) {
    s = { user: slug, visits: 1, previousVisit: false, lastVisit: today, disliked: false };
  } else {
    if (s.lastVisit !== today) {
      s.visits = (s.visits || 0) + 1;
      s.previousVisit = s.lastVisit || false;
      s.lastVisit = today;
      if (!s.user) s.user = slug;
      if (typeof s.disliked !== 'boolean') s.disliked = false;
    }
  }

  pgSaveSummary(slug, s);
  return s;
}

function pgTextContains(el, txt) { return el && typeof el.textContent === 'string' && el.textContent.trim() === txt; }

function pgCopyText(str) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(str).catch(() => { });
  } else {
    const t = document.createElement('textarea');
    t.value = str;
    document.body.appendChild(t);
    t.select();
    try { document.execCommand('copy'); } catch { }
    t.remove();
  }
}

function pgEnhanceUserPages(root) {
  const up = location.pathname.match(/\/user\/([^/]+)$/);
  const upp = location.pathname.match(/\/user\/([^/]+)\/post/);
  if (!up && !upp) return;

  const slug = (up || upp)[1];
  const cssPrefix = up ? 'user-header' : 'post';
  const summary = pgEnsureVisit(slug);

  if (up) {
    if (!document.querySelector('.pg-visit-summary')) {
      const parent = $(`.${cssPrefix}__info`);
      if (parent) {
        const wrap = document.createElement('div');
        const span = document.createElement('span');
        span.className = 'pg-visit-summary';
        span.textContent = summary.previousVisit ? `Visited ${summary.visits} times, last visit on ${summary.previousVisit}` : `First visit`;
        wrap.appendChild(span);
        parent.appendChild(wrap);
      }
    }
  } else {
    if (!document.querySelector('.pg-visit-summary')) {
      const parent = $(`.${cssPrefix}__published`);
      if (parent) {
        const span = document.createElement('span');
        span.className = 'pg-visit-summary';
        span.textContent = summary.previousVisit ? `Visited ${summary.visits} times, last visit on ${summary.previousVisit}` : `First visit`;
        parent.appendChild(span);
      }
    }

    const navTop = $('nav.post__nav-links'), footer = $('footer.post__footer');
    if (navTop && footer && !footer.querySelector('.pg-nav-clone')) {
      const clone = navTop.cloneNode(true);
      clone.classList.add('pg-nav-clone');
      footer.appendChild(clone);
    }

    if (root.querySelectorAll || root.tagName === 'H2') {
      const headers = root.tagName === 'H2' ? [root] : document.querySelectorAll('h2');
      headers.forEach(h => {
        if (pgTextContains(h, 'Downloads') && !h.querySelector('.pg-copy-btn')) {
          const btn = document.createElement('button');
          btn.type = 'button'; btn.className = 'pg-btn pg-copy-btn'; btn.textContent = 'Copy';
          btn.onclick = () => {
            let out = ''; let c = 0;
            document.querySelectorAll('a.post__attachment-link').forEach(a => { out += a.href + '\n'; c++; });
            if (out) pgCopyText(out);
          };
          h.appendChild(btn);
        }
      });
    }
  }

  if (!$(`.${cssPrefix}__actions .pg-dislike-btn`)) {
    const act = $(`.${cssPrefix}__actions`);
    if (act) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'pg-btn pg-dislike-btn';
      btn.textContent = summary.disliked ? 'Undislike' : 'Dislike';
      btn.onclick = () => {
        const s = pgLoadSummary(slug) || { user: slug, visits: 1, previousVisit: false, lastVisit: pgTodayISO(), disliked: false };
        s.disliked = !s.disliked;
        pgSaveSummary(slug, s);
        btn.textContent = s.disliked ? 'Undislike' : 'Dislike';
      };
      act.appendChild(btn);
    }
  }
}

function pgEnhanceArtists(root) {
  if (!/\/artists/.test(location.pathname)) return;

  const processCard = card => {
    if (!card || card.classList.contains('pg-enhanced')) return;
    const summary = pgExtractSummary(card.href);
    card.classList.add('pg-enhanced');
    const svc = card.querySelector('span.user-card__service');

    if (summary) {
      const visits = document.createElement('span'); visits.className = 'pg-badge'; visits.textContent = `Visits: ${summary.visits || 0}`;
      if (svc) svc.insertAdjacentElement('afterend', visits);

      if (summary.previousVisit) {
        const days = Math.floor((new Date() - new Date(summary.previousVisit)) / (1000 * 60 * 60 * 24));
        const d = document.createElement('span'); d.className = 'pg-badge'; d.textContent = `Days: ${days}`; d.title = `Last visit: ${summary.previousVisit}`;
        visits.insertAdjacentElement('afterend', d);
      }

      if (summary.disliked) card.classList.add('pg-card-dislike');
    } else {
      card.classList.add('pg-card-new');
    }
  };

  if (root.tagName === 'A' && root.classList.contains('user-card')) {
    processCard(root);
  } else {
    root.querySelectorAll && root.querySelectorAll('a.user-card').forEach(processCard);
  }
}

function pgEnhancePostsList(root) {
  if (!/\/posts/.test(location.pathname)) return;

  const processCard = card => {
    if (!card || card.classList.contains('pg-enhanced')) return;
    const link = card.querySelector('a'); if (!link) return;
    const data = pgExtractSummary(link.href, true);
    card.classList.add('pg-enhanced');

    const footDiv = card.querySelector('footer > div');
    if (data && typeof data === 'object') {
      if (footDiv) footDiv.textContent = `${data.user || ''} (${data.visits || 0})`;
      if (data.disliked) card.classList.add('pg-card-dislike');
    } else if (typeof data === 'string') {
      if (footDiv) footDiv.textContent = data;
      card.classList.add('pg-card-new');
    }
  };

  if (root.tagName === 'ARTICLE' && root.classList.contains('post-card')) {
    processCard(root);
  } else {
    root.querySelectorAll && root.querySelectorAll('article.post-card').forEach(processCard);
  }
}

function pgOptimizeRoot(root) {
  pgEnhanceUserPages(root);
  pgEnhanceArtists(root);
  pgEnhancePostsList(root);
}



buildHUD();
injectPostNumbers();

const observer = new MutationObserver(debounce(injectPostNumbers, 100));
observer.observe(document.body, { childList: true, subtree: true });

const optimizerObserver = new MutationObserver(muts => {
  for (const m of muts) {
    if (m.type === 'childList' && m.addedNodes.length) {
      pgOptimizeRoot(m.addedNodes[0]);
    }
  }
});
optimizerObserver.observe(document.body, { childList: true, subtree: true });

pgOptimizeRoot(document.body);
window.addEventListener('resize', syncFilterBoxWidth);
